<!DOCTYPE html>
<html>
<head>
    <title>MetaData Refiner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital@0;1&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/main.css">
</head>
<body>
    <!-- Toast notification container -->
    <div id="toast-container" class="position-fixed bottom-0 end-0 p-3" style="z-index: 1100;"></div>

    <div class="container app-shell py-3">
        <header class="d-flex justify-content-between align-items-center mb-3">
            <div class="brand" aria-label="MetaData Refiner">
                <svg id="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 387.89 89.6" style="height: 60px; width: auto;">
                    <path class="logo-fill" d="M21.54,38.83V6.76c0-.48.29-.77.77-.77h8.88c.48,0,.77.24,1.06.72l14.74,24.05h.62l14.74-24.05c.29-.48.58-.72,1.06-.72h8.88c.48,0,.77.29.77.77v32.07c0,.48-.29.77-.77.77h-6.14c-.48,0-.72-.29-.72-.77v-22.61h-.53l-13.83,22.61c-.29.48-.62.77-1.15.77h-5.23c-.53,0-.86-.29-1.15-.77l-13.83-22.61h-.53v22.61c0,.48-.24.77-.72.77h-6.14c-.48,0-.77-.29-.77-.77Z"/>
                    <path class="logo-fill" d="M117.5,33.65v5.23c0,.48-.24.72-.72.72h-37.92c-.48,0-.77-.29-.77-.77V6.76c0-.48.29-.77.77-.77h37.68c.48,0,.72.24.72.72v5.23c0,.48-.24.72-.72.72h-30.82v6.77h30.34c.48,0,.72.24.72.72v5.28c0,.48-.24.72-.72.72h-30.34v6.77h31.06c.48,0,.72.24.72.72Z"/>
                    <path class="logo-fill" d="M163.62,6.76v5.18c0,.48-.29.72-.77.72h-16.75v26.16c0,.48-.29.77-.77.77h-5.95c-.48,0-.77-.29-.77-.77V12.67h-16.75c-.48,0-.77-.24-.77-.72v-5.18c0-.48.29-.77.77-.77h41c.48,0,.77.29.77.77Z"/>
                    <path class="logo-fill" d="M208.7,39.6h-7.15c-.58,0-.82-.34-1.15-.86l-2.88-4.46h-26.5l-2.88,4.46c-.34.53-.58.86-1.1.86h-7.2c-.48,0-.82-.38-.38-1.01l20.55-31.83c.29-.48.53-.77,1.06-.77h6.43c.53,0,.82.29,1.1.77l20.5,31.83c.43.62.1,1.01-.38,1.01ZM193.33,27.74l-8.74-13.63h-.62l-8.79,13.63h18.15Z"/>
                    <path class="logo-fill" d="M257.7,14.78v16.03c0,5.47-2.59,8.78-8.54,8.78h-35.33c-.48,0-.77-.29-.77-.77V6.76c0-.48.29-.77.77-.77h35.33c5.95,0,8.54,3.31,8.54,8.78ZM250.12,15.31c0-1.97-.86-2.64-2.64-2.64h-26.79v20.26h26.79c1.78,0,2.64-.67,2.64-2.64v-14.98Z"/>
                    <path class="logo-fill" d="M309.26,39.6h-7.15c-.58,0-.82-.34-1.15-.86l-2.88-4.46h-26.5l-2.88,4.46c-.34.53-.58.86-1.1.86h-7.2c-.48,0-.82-.38-.38-1.01l20.55-31.83c.29-.48.53-.77,1.06-.77h6.43c.53,0,.82.29,1.1.77l20.5,31.83c.43.62.1,1.01-.38,1.01ZM293.89,27.74l-8.74-13.63h-.62l-8.79,13.63h18.15Z"/>
                    <path class="logo-fill" d="M345.11,6.76v5.18c0,.48-.29.72-.77.72h-16.75v26.16c0,.48-.29.77-.77.77h-5.95c-.48,0-.77-.29-.77-.77V12.67h-16.75c-.48,0-.77-.24-.77-.72v-5.18c0-.48.29-.77.77-.77h41c.48,0,.77.29.77.77Z"/>
                    <path class="logo-fill" d="M387.3,39.6h-7.15c-.58,0-.82-.34-1.15-.86l-2.88-4.46h-26.5l-2.88,4.46c-.34.53-.58.86-1.1.86h-7.2c-.48,0-.82-.38-.38-1.01l20.55-31.83c.29-.48.53-.77,1.06-.77h6.43c.53,0,.82.29,1.1.77l20.5,31.83c.43.62.1,1.01-.38,1.01ZM371.94,27.74l-8.74-13.63h-.62l-8.79,13.63h18.15Z"/>
                    <path class="logo-fill" d="M62.01,83.6h-5.57c-.58,0-.96-.29-1.34-.82l-5.38-7.92h-20.55v7.97c0,.48-.24.77-.72.77h-6.14c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77h31.59c5.95,0,8.54,3.31,8.54,8.78v7.34c0,4.13-1.49,7.01-4.85,8.16l5.33,8.06c.48.67-.1,1.25-.91,1.25ZM29.17,68.19h22.95c1.78,0,2.69-.67,2.69-2.64v-6.24c0-1.97-.91-2.64-2.69-2.64h-22.95v11.52Z"/>
                    <path class="logo-fill" d="M107.27,77.65v5.23c0,.48-.24.72-.72.72h-37.92c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77h37.68c.48,0,.72.24.72.72v5.23c0,.48-.24.72-.72.72h-30.82v6.77h30.34c.48,0,.72.24.72.72v5.28c0,.48-.24.72-.72.72h-30.34v6.77h31.06c.48,0,.72.24.72.72Z"/>
                    <path class="logo-fill" d="M151,50.72v5.23c0,.48-.24.72-.72.72h-30.82v5.81h30.34c.48,0,.72.24.72.72v5.23c0,.48-.24.72-.72.72h-30.34v13.68c0,.48-.24.77-.72.77h-6.14c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77h37.68c.48,0,.72.24.72.72Z"/>
                    <path class="logo-fill" d="M156.32,50h6.15c.48,0,.72.29.72.77v32.07c0,.48-.24.77-.72.77h-6.15c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77Z"/>
                    <path class="logo-fill" d="M168.23,82.83v-32.07c0-.48.29-.77.77-.77h7.15c.43,0,.62.19,1.06.58l25.35,24h.67v-23.81c0-.48.24-.77.72-.77h6.14c.48,0,.77.29.77.77v32.07c0,.48-.29.77-.77.77h-7.15c-.43,0-.62-.19-1.06-.58l-25.35-24h-.67v23.81c0,.48-.24.77-.72.77h-6.14c-.48,0-.77-.29-.77-.77Z"/>
                    <path class="logo-fill" d="M255.3,77.65v5.23c0,.48-.24.72-.72.72h-37.92c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77h37.68c.48,0,.72.24.72.72v5.23c0,.48-.24.72-.72.72h-30.82v6.77h30.34c.48,0,.72.24.72.72v5.28c0,.48-.24.72-.72.72h-30.34v6.77h31.06c.48,0,.72.24.72.72Z"/>
                    <path class="logo-fill" d="M300.33,83.6h-5.57c-.58,0-.96-.29-1.34-.82l-5.38-7.92h-20.55v7.97c0,.48-.24.77-.72.77h-6.14c-.48,0-.77-.29-.77-.77v-32.07c0-.48.29-.77.77-.77h31.59c5.95,0,8.54,3.31,8.54,8.78v7.34c0,4.13-1.49,7.01-4.85,8.16l5.33,8.06c.48.67-.1,1.25-.91,1.25ZM267.49,68.19h22.95c1.78,0,2.69-.67,2.69-2.64v-6.24c0-1.97-.91-2.64-2.69-2.64h-22.95v11.52Z"/>
                    <rect class="logo-fill" width="9.87" height="89.6"/>
                </svg>
            </div>
            <div class="d-flex align-items-center gap-2">
                <div class="d-none d-md-flex align-items-center gap-2">
                    <label class="form-label m-0 small text-muted">Profile</label>
                    <select id="profile-select" class="form-select form-select-sm" style="min-width: 220px"></select>
                </div>
                <button id="settings-btn" class="btn btn-outline-secondary btn-sm">Settings</button>
            </div>
        </header>

        <section class="mb-4 app-layout">
            <aside class="sidebar">
                <div id="drop-zone" class="mb-3">
                    <div class="drop-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" focusable="false" role="img">
                            <path d="M12 3c.26 0 .52.1.71.29l5 5a1 1 0 1 1-1.42 1.42L13 6.41V16a1 1 0 1 1-2 0V6.41L7.71 9.71A1 1 0 0 1 6.29 8.29l5-5A1 1 0 0 1 12 3z" />
                            <path d="M5 18a1 1 0 1 0 0 2h14a1 1 0 1 0 0-2H5z" />
                        </svg>
                    </div>
                    <p class="mb-1">Drag & drop images here</p>
                    <p class="text-muted small">JPG, PNG, GIF, BMP, WebP up to 10MB</p>
                    <input type="file" id="file-input" multiple accept="image/*" class="form-control mt-3">
                    <div class="mt-2">
                        <button id="browse-files" class="btn btn-outline-primary w-100">Browse Files...</button>
                    </div>
                </div>

                <div class="actions-bar p-3 d-flex flex-column gap-3">
                    <div class="d-grid gap-2">
                        <button id="generate-all" class="btn btn-primary" disabled>Generate All Metadata</button>
                        <button id="generate-selected" class="btn btn-outline-primary" disabled>Generate Selected</button>
                        <button id="delete-selected" class="btn btn-outline-danger" disabled>Delete Selected</button>
                        <button id="export" class="btn btn-success" disabled>Export to CSV</button>
                    </div>
                    <div class="d-flex flex-wrap align-items-center gap-2">
                        <div class="btn-group" role="group" aria-label="View mode">
                            <input type="radio" class="btn-check" name="view-mode" id="view-grid" autocomplete="off">
                            <label class="btn btn-outline-secondary btn-sm" for="view-grid">Grid</label>
                            <input type="radio" class="btn-check" name="view-mode" id="view-list" autocomplete="off">
                            <label class="btn btn-outline-secondary btn-sm" for="view-list">List</label>
                            <input type="radio" class="btn-check" name="view-mode" id="view-table" autocomplete="off">
                            <label class="btn btn-outline-secondary btn-sm" for="view-table">Table</label>
                        </div>
                    </div>
                    <div class="input-group input-group-sm">
                        <span class="input-group-text">Search</span>
                        <input id="search-input" type="text" class="form-control" placeholder="Filename, title, tags..." />
                    </div>
                    <div class="text-muted small" id="selection-info">0 selected</div>
                    <div id="cost-estimate" class="border p-2 px-3" style="display: none; background: var(--panel-bg); border-color: var(--panel-border);">
                        <span class="me-3">Fresh: <strong id="fresh-cost">$0.00</strong></span>
                        <span>Cached: <strong id="cached-cost">$0.00</strong></span>
                    </div>

                    <!-- Batch Progress Bar -->
                    <div id="batch-progress" class="border rounded p-3" style="display: none; background: var(--panel-bg); border-color: var(--panel-border);">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span><strong id="progress-current">0</strong> / <span id="progress-total">0</span></span>
                            <span class="text-muted small" id="progress-eta"></span>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar bg-success" id="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div class="mt-2 text-end">
                            <button id="cancel-batch" class="btn btn-sm btn-outline-danger">Cancel</button>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="content">
                <section id="image-grid" class="row"></section>
            </main>
        </section>
    </div>

    <div id="settings-modal" class="modal fade" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">API Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="api-key" class="form-label">OpenAI API Key</label>
                        <input type="password" class="form-control" id="api-key" 
                               placeholder="sk-...">
                        <div class="form-text">Key is stored in browser localStorage. Alternatively, set OPENAI_API_KEY in your .env file.</div>
                    </div>
                    <div class="mb-3">
                        <label for="base-path" class="form-label">Base Path for CSV Export</label>
                        <input type="text" class="form-control" id="base-path" 
                               placeholder="e.g., C:/Users/MyName/Pictures">
                        <div class="form-text">If provided, this path will be prepended to image paths in CSV exports</div>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="show-cost-estimate" checked>
                            <label class="form-check-label" for="show-cost-estimate">Show Cost Estimates</label>
                        </div>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="dark-mode">
                            <label class="form-check-label" for="dark-mode">Dark Mode</label>
                        </div>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="severed-mode">
                            <label class="form-check-label" for="severed-mode">Severed Mode (retro corporate)</label>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" onclick="saveSettings()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Theme management
        function applyTheme(isDark) {
            document.body.setAttribute('data-bs-theme', isDark ? 'dark' : 'light');
        }
        function applyStyle(isSevered) {
            document.body.setAttribute('data-style', isSevered ? 'severed' : 'default');
        }

        // Settings handling
        function showSettings() {
            const modal = new bootstrap.Modal('#settings-modal');
            document.getElementById('api-key').value = localStorage.getItem('openai-key') || '';
            document.getElementById('base-path').value = localStorage.getItem('base-path') || '';
            document.getElementById('show-cost-estimate').checked = localStorage.getItem('show-cost-estimate') !== 'false';
            document.getElementById('dark-mode').checked = localStorage.getItem('dark-mode') === 'true';
            document.getElementById('severed-mode').checked = localStorage.getItem('severed-mode') === 'true';
            modal.show();
        }

        function saveSettings() {
            const key = document.getElementById('api-key').value.trim();
            const showCostEstimate = document.getElementById('show-cost-estimate').checked;
            const basePath = document.getElementById('base-path').value.trim();
            const darkMode = document.getElementById('dark-mode').checked;
            const severedMode = document.getElementById('severed-mode').checked;
            
            if (key) {
                localStorage.setItem('openai-key', key);
            }
            localStorage.setItem('show-cost-estimate', showCostEstimate);
            localStorage.setItem('base-path', basePath);
            localStorage.setItem('dark-mode', darkMode);
            localStorage.setItem('severed-mode', severedMode);
            
            document.getElementById('cost-estimate').style.display = 
                showCostEstimate ? 'block' : 'none';
            
            applyTheme(darkMode);
            applyStyle(severedMode);
            
            bootstrap.Modal.getInstance('#settings-modal').hide();
            updateCostEstimate();
        }

        function checkApiKey() {
            // Allow processing to proceed - the server will check .env first,
            // then fall back to localStorage if needed
            const hasLocalKey = !!localStorage.getItem('openai-key');
            // Note: We can't check server-side .env from frontend, so we'll let
            // the server handle the API key resolution and show error if needed
            return true; // Always return true, let server handle the validation
        }

        // Cost estimation
        function updateCostEstimate() {
            const imageCount = document.querySelectorAll('.image-card').length;
            if (imageCount === 0) {
                document.getElementById('fresh-cost').textContent = '$0.00';
                document.getElementById('cached-cost').textContent = '$0.00';
                return;
            }

            // Estimate tokens per image
            const inputTokensPerImage = 25000; // system prompt + base64 image
            const outputTokensPerImage = 100; // JSON response

            // Calculate costs for GPT-5-nano
            const inputCostPerMillion = 0.05; // $0.05 per million tokens
            const cachedCostPerMillion = 0.005; // $0.005 per million tokens (90% discount)
            const outputCostPerMillion = 0.40; // $0.40 per million tokens

            const totalInputTokens = inputTokensPerImage * imageCount;
            const totalOutputTokens = outputTokensPerImage * imageCount;

            const freshCost = 
                (totalInputTokens / 1000000 * inputCostPerMillion) +
                (totalOutputTokens / 1000000 * outputCostPerMillion);
            
            const cachedCost = 
                (totalInputTokens / 1000000 * cachedCostPerMillion) +
                (totalOutputTokens / 1000000 * outputCostPerMillion);

            document.getElementById('fresh-cost').textContent = 
                `$${freshCost.toFixed(4)}`;
            document.getElementById('cached-cost').textContent = 
                `$${cachedCost.toFixed(4)}`;
        }

        // Add event listener for settings button
        document.getElementById('settings-btn').addEventListener('click', showSettings);

        // Detect if running in Electron (via preload script)
        const isElectron = window.electronAPI && window.electronAPI.isElectron;

        // Add API key to all fetch requests
        const originalFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            options.headers = options.headers || {};
            options.headers['X-OpenAI-Key'] = localStorage.getItem('openai-key') || '';
            return originalFetch(url, options);
        };

        const socket = io();

        // Electron-specific functionality (uses secure preload bridge)
        if (isElectron) {
            // Listen for files selected from menu
            window.electronAPI.onFilesSelected((filePaths) => {
                // Convert file paths to File objects and handle them
                Promise.all(filePaths.map(filePath => {
                    return fetch(`file://${filePath}`)
                        .then(res => res.blob())
                        .then(blob => {
                            const filename = filePath.split(/[\\\/]/).pop();
                            return new File([blob], filename, { type: blob.type });
                        });
                })).then(files => {
                    handleFiles(files);
                });
            });

            // Show notification when processing completes
            window.showElectronNotification = function(title, body) {
                window.electronAPI.showNotification(title, body);
            };
        }
        let currentProfile = null;
        let profilesConfig = {};
        // Centralized state for scalable rendering
        let imagesState = []; // [{full_path, file_path?, fields:{}, status:'ready'|'processing'|'complete'|'error'}]
        let selectedPaths = new Set();
        let viewMode = localStorage.getItem('view-mode') || 'grid';
        let searchQuery = '';

        // Helper functions

        // Toast notification for categorized errors
        function showToast(data) {
            const container = document.getElementById('toast-container');
            const colors = {
                auth: 'danger',
                quota: 'warning',
                timeout: 'info',
                network: 'info',
                model: 'secondary',
                server: 'secondary'
            };
            const bgColor = colors[data.category] || 'secondary';
            const filename = data.image ? data.image.split('/').pop() : 'Unknown';

            const toast = document.createElement('div');
            toast.className = `toast show border-start border-4 border-${bgColor}`;
            toast.setAttribute('role', 'alert');
            toast.innerHTML = `
                <div class="toast-header">
                    <strong class="me-auto text-${bgColor}">${data.title || 'Error'}</strong>
                    <small class="text-muted">${filename}</small>
                    <button type="button" class="btn-close" onclick="this.closest('.toast').remove()"></button>
                </div>
                <div class="toast-body">
                    <p class="mb-1">${data.message || 'An error occurred'}</p>
                    ${data.action ? `<p class="small text-muted mb-2">${data.action}</p>` : ''}
                    ${data.retry_allowed && data.image ? `<button class="btn btn-sm btn-outline-primary" onclick="retryImage('${data.image}'); this.closest('.toast').remove();">Retry</button>` : ''}
                </div>
            `;
            container.appendChild(toast);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (toast.parentNode) toast.remove();
            }, 10000);
        }

        // Retry a single image
        function retryImage(imagePath) {
            const item = getImageByPath(imagePath);
            if (item) {
                item.status = 'ready';
                queueGeneration([imagePath]);
            }
        }

        function generateCategoryOptions(categories, selectedValue) {
            return categories.map(cat => 
                `<option value="${cat}" ${cat === selectedValue ? 'selected' : ''}>${cat}</option>`
            ).join('');
        }

        function createMetadataFields(profile, imageData = {}) {
            return profile.required_fields.map(field => {
                const value = imageData[field] || '';
                if (field === 'category') {
                    return `
                        <div class="mb-3">
                            <label>Category</label>
                            <select class="form-select category-input">
                                ${generateCategoryOptions(profile.categories, value)}
                            </select>
                        </div>`;
                }
                return `
                    <div class="mb-3">
                        <label>${field.charAt(0).toUpperCase() + field.slice(1)}</label>
                        ${field === 'description' ? 
                            `<textarea class="form-control ${field}-input">${value}</textarea>` :
                            `<input type="text" class="form-control ${field}-input" value="${value}">`}
                    </div>`;
            }).join('');
        }

        function updateAllCards() { renderImages(); }

        function getImageByPath(path) {
            return imagesState.find(img => img.full_path === path);
        }

        function syncInputsToState(card, image) {
            currentProfile.required_fields.forEach(field => {
                const input = card.querySelector(`.${field}-input`);
                if (!input) return;
                const handler = () => {
                    image.fields[field] = input.value;
                };
                input.addEventListener('input', handler);
                // Initialize from state if present
                if (image.fields[field]) input.value = image.fields[field];
            });
            // Category select
            const sel = card.querySelector('.category-input');
            if (sel) {
                sel.addEventListener('change', () => { image.fields['category'] = sel.value; });
                if (image.fields['category']) sel.value = image.fields['category'];
            }
        }

        function matchesSearch(image) {
            if (!searchQuery) return true;
            const q = searchQuery.toLowerCase();
            const fields = Object.values(image.fields || {}).join(' ').toLowerCase();
            return image.full_path.toLowerCase().includes(q) || fields.includes(q);
        }

        // Lazy loading configuration
        const BATCH_SIZE = 20;
        let renderedCount = 0;
        let scrollObserver = null;

        // Session state persistence
        const SESSION_KEY = 'mdr-session-state';
        const SESSION_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

        function saveSessionState() {
            const state = {
                images: imagesState,
                selectedPaths: Array.from(selectedPaths),
                profile: document.getElementById('profile-select')?.value || 'zedge',
                viewMode: viewMode,
                timestamp: Date.now()
            };
            try {
                localStorage.setItem(SESSION_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save session state:', e);
            }
        }

        function loadSessionState() {
            try {
                const saved = localStorage.getItem(SESSION_KEY);
                if (!saved) return null;

                const state = JSON.parse(saved);
                // Check if expired
                if (Date.now() - state.timestamp > SESSION_EXPIRY) {
                    localStorage.removeItem(SESSION_KEY);
                    return null;
                }
                return state;
            } catch (e) {
                console.warn('Could not load session state:', e);
                return null;
            }
        }

        function clearSessionState() {
            localStorage.removeItem(SESSION_KEY);
        }

        // Auto-save on state changes (debounced)
        let saveTimeout = null;
        function scheduleStateSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveSessionState, 1000);
        }

        // Progress tracker for batch processing
        const progressTracker = {
            total: 0,
            completed: 0,
            startTime: null,
            times: [],
            cancelled: false,

            start(total) {
                this.total = total;
                this.completed = 0;
                this.startTime = Date.now();
                this.times = [];
                this.cancelled = false;
                document.getElementById('batch-progress').style.display = 'block';
                this.update();
            },

            complete() {
                this.times.push(Date.now());
                this.completed++;
                this.update();

                if (this.completed >= this.total) {
                    setTimeout(() => {
                        document.getElementById('batch-progress').style.display = 'none';
                    }, 2000);
                }
            },

            cancel() {
                this.cancelled = true;
                document.getElementById('batch-progress').style.display = 'none';
            },

            update() {
                const pct = this.total > 0 ? Math.round((this.completed / this.total) * 100) : 0;
                document.getElementById('progress-bar').style.width = `${pct}%`;
                document.getElementById('progress-current').textContent = this.completed;
                document.getElementById('progress-total').textContent = this.total;

                // Calculate ETA
                if (this.times.length > 0 && this.completed < this.total) {
                    const avgTime = (this.times[this.times.length - 1] - this.startTime) / this.completed;
                    const remaining = Math.round((this.total - this.completed) * avgTime / 1000);
                    const mins = Math.floor(remaining / 60);
                    const secs = remaining % 60;
                    document.getElementById('progress-eta').textContent =
                        mins > 0 ? `~${mins}m ${secs}s left` : `~${secs}s left`;
                } else {
                    document.getElementById('progress-eta').textContent = '';
                }
            }
        };

        function renderImages() {
            const grid = document.getElementById('image-grid');
            grid.innerHTML = '';
            renderedCount = 0;

            // Clean up previous observer
            if (scrollObserver) {
                scrollObserver.disconnect();
                scrollObserver = null;
            }

            const filtered = imagesState.filter(matchesSearch);
            if (viewMode === 'table') {
                const table = document.createElement('table');
                table.className = 'table table-hover align-middle rounded-3 overflow-hidden greenbar';
                table.innerHTML = `
                    <colgroup>
                        <col style="width:36px">
                        <col style="width:420px">
                        <col style="width:240px">
                        <col style="width:300px">
                        <col style="width:240px">
                        <col style="width:160px">
                        <col style="width:110px">
                        <col style="width:96px">
                    </colgroup>
                    <thead class="table-light">
                        <tr>
                            <th style="width:36px"><input type="checkbox" id="select-all"></th>
                            <th>Image</th>
                            <th>Title</th>
                            <th>Description</th>
                            <th>Tags</th>
                            <th style="width:160px">Category</th>
                            <th style="width:120px">Status</th>
                            <th style="width:120px">Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>`;
                const tbody = table.querySelector('tbody');
                filtered.forEach(image => {
                    const tr = document.createElement('tr');
                    tr.dataset.imagePath = image.full_path;
                    tr.innerHTML = `
                        <td><input type="checkbox" class="row-select" ${selectedPaths.has(image.full_path)?'checked':''}></td>
                        <td class="d-flex align-items-center gap-2">
                            <div class="thumb-wrap" style="width:72px;height:72px;border-radius:8px;overflow:hidden;">
                                <img src="${image.full_path}" alt="thumb" loading="lazy" style="width:72px;height:72px;object-fit:cover;display:block;">
                            </div>
                            <span class="filename" title="${image.full_path.split('/').pop()}">${image.full_path.split('/').pop()}</span>
                        </td>
                        <td><input type="text" class="form-control form-control-sm title-input" value="${image.fields.title||''}"></td>
                        <td><textarea rows="1" class="form-control form-control-sm description-input">${image.fields.description||''}</textarea></td>
                        <td><input type="text" class="form-control form-control-sm tags-input" value="${image.fields.tags||''}"></td>
                        <td>
                            <select class="form-select form-select-sm category-input">
                                ${generateCategoryOptions(currentProfile.categories, image.fields.category||'')}
                            </select>
                        </td>
                        <td>
                            <span class="badge ${image.status==='complete'?'text-bg-success':image.status==='processing'?'text-bg-info':image.status==='error'?'text-bg-danger':'text-bg-secondary'}">${(image.status||'ready')[0].toUpperCase()+ (image.status||'ready').slice(1)}</span>
                        </td>
                        <td>
                            <div class="btn-group" role="group">
                                <button class="btn btn-outline-primary btn-compact regenerate" title="Regenerate" aria-label="Regenerate">
                                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.75 6h-2.06A6 6 0 1 1 12 6c1.66 0 3.14.69 4.22 1.78L14 10h6V4l-2.35 2.35z"/></svg>
                                </button>
                                <button class="btn btn-outline-danger btn-compact delete" title="Delete" aria-label="Delete">
                                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M6 7h12l-1 12a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2L6 7zm5-3h2a1 1 0 0 1 1 1v1h4v2H4V6h4V5a1 1 0 0 1 1-1z"/></svg>
                                </button>
                            </div>
                        </td>`;
                    tbody.appendChild(tr);

                    // Bind form inputs (still needed for field syncing)
                    syncInputsToState(tr, image);
                });

                grid.appendChild(table);

                // Update select-all checkbox state (event handling done via delegation)
                const selectAll = table.querySelector('#select-all');
                if (selectAll) {
                    selectAll.checked = filtered.length > 0 && filtered.every(img => selectedPaths.has(img.full_path));
                }
            } else if (viewMode === 'grid') {
                // Use lazy loading for grid view with many images
                if (filtered.length > BATCH_SIZE) {
                    // Render initial batch
                    const initialBatch = filtered.slice(0, BATCH_SIZE);
                    initialBatch.forEach(img => grid.appendChild(createGridCard(img)));
                    renderedCount = initialBatch.length;

                    // Add sentinel element for infinite scroll
                    if (renderedCount < filtered.length) {
                        const sentinel = document.createElement('div');
                        sentinel.className = 'scroll-sentinel col-12 text-center py-3';
                        sentinel.innerHTML = '<div class="spinner-border spinner-border-sm text-muted" role="status"></div><span class="ms-2 text-muted">Loading more...</span>';
                        grid.appendChild(sentinel);

                        // Set up intersection observer
                        scrollObserver = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting && renderedCount < filtered.length) {
                                // Remove sentinel temporarily
                                sentinel.remove();

                                // Render next batch
                                const nextBatch = filtered.slice(renderedCount, renderedCount + BATCH_SIZE);
                                nextBatch.forEach(img => grid.appendChild(createGridCard(img)));
                                renderedCount += nextBatch.length;

                                // Re-add sentinel if more images remain
                                if (renderedCount < filtered.length) {
                                    grid.appendChild(sentinel);
                                }
                            }
                        }, { rootMargin: '100px' });

                        scrollObserver.observe(sentinel);
                    }
                } else {
                    // Small set, render all at once
                    filtered.forEach(img => grid.appendChild(createGridCard(img)));
                }
            } else if (viewMode === 'list') {
                const wrapper = document.createElement('div');
                wrapper.className = 'col-12';
                filtered.forEach(img => wrapper.appendChild(createListItem(img)));
                grid.appendChild(wrapper);
            }

            // Enable/disable action buttons
            document.getElementById('generate-selected').disabled = selectedPaths.size === 0;
            document.getElementById('delete-selected').disabled = selectedPaths.size === 0;
            document.getElementById('export').disabled = imagesState.length === 0;
            document.getElementById('generate-all').disabled = imagesState.length === 0 || processingCount>0;
            updateSelectionInfo();
        }

        // Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize theme
            const darkMode = localStorage.getItem('dark-mode') === 'true';
            applyTheme(darkMode);
            const severedMode = localStorage.getItem('severed-mode') === 'true';
            applyStyle(severedMode);
            
            const response = await fetch('/api/profiles');
            const data = await response.json();
            profilesConfig = data.profiles;
            
            const profileSelect = document.getElementById('profile-select');
            profileSelect.innerHTML = Object.entries(profilesConfig).map(([id, profile]) =>
                `<option value="${id}">${profile.name}</option>`
            ).join('');
            
            profileSelect.value = data.default_profile;
            currentProfile = profilesConfig[data.default_profile];
            
            profileSelect.addEventListener('change', () => {
                currentProfile = profilesConfig[profileSelect.value];
                updateAllCards();
                scheduleStateSave();
            });

            // Session recovery - check for saved state
            const savedState = loadSessionState();
            if (savedState && savedState.images && savedState.images.length > 0) {
                const timeAgo = Math.round((Date.now() - savedState.timestamp) / 60000);
                const timeStr = timeAgo < 60 ? `${timeAgo} minutes` : `${Math.round(timeAgo / 60)} hours`;

                if (confirm(`Found ${savedState.images.length} images from ${timeStr} ago. Restore session?`)) {
                    imagesState = savedState.images;
                    selectedPaths = new Set(savedState.selectedPaths || []);
                    if (savedState.profile && profilesConfig[savedState.profile]) {
                        profileSelect.value = savedState.profile;
                        currentProfile = profilesConfig[savedState.profile];
                    }
                    if (savedState.viewMode) {
                        viewMode = savedState.viewMode;
                    }
                    renderImages();
                    updateCostEstimate();
                } else {
                    clearSessionState();
                }
            }

            // Initialize cost estimate display
            const showCostEstimate = localStorage.getItem('show-cost-estimate') !== 'false';
            document.getElementById('cost-estimate').style.display = 
                showCostEstimate ? 'block' : 'none';

            // View mode setup
            document.getElementById('view-grid').checked = viewMode === 'grid';
            const listRadio = document.getElementById('view-list');
            const tableRadio = document.getElementById('view-table');
            listRadio.checked = viewMode === 'list';
            tableRadio.checked = viewMode === 'table';
            document.getElementById('view-grid').addEventListener('change', ()=>{ viewMode='grid'; localStorage.setItem('view-mode','grid'); renderImages(); });
            listRadio.addEventListener('change', ()=>{ viewMode='list'; localStorage.setItem('view-mode','list'); renderImages(); });
            tableRadio.addEventListener('change', ()=>{ viewMode='table'; localStorage.setItem('view-mode','table'); renderImages(); });
            document.getElementById('search-input').addEventListener('input', (e)=>{ searchQuery = e.target.value.trim(); renderImages(); });
        });

        // File handling
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        // Event delegation for image grid - handles all click/change events
        document.getElementById('image-grid').addEventListener('click', (e) => {
            const target = e.target;

            // Find the image container (card, list-item, or table row)
            const imageContainer = target.closest('[data-image-path]');
            if (!imageContainer) return;

            const imagePath = imageContainer.dataset.imagePath;

            // Delete button clicked
            if (target.closest('.delete-btn') || target.closest('.delete')) {
                e.preventDefault();
                imagesState = imagesState.filter(i => i.full_path !== imagePath);
                selectedPaths.delete(imagePath);
                renderImages();
                updateSelectionInfo();
                updateCostEstimate();
                scheduleStateSave();
                return;
            }

            // Regenerate button clicked
            if (target.closest('.generate-single') || target.closest('.regenerate')) {
                e.preventDefault();
                queueGeneration([imagePath]);
                return;
            }
        });

        // Separate handler for change events (checkboxes)
        document.getElementById('image-grid').addEventListener('change', (e) => {
            const target = e.target;

            // Selection checkbox changed
            if (target.classList.contains('select-checkbox') || target.classList.contains('row-select')) {
                const imageContainer = target.closest('[data-image-path]');
                if (!imageContainer) return;

                const imagePath = imageContainer.dataset.imagePath;
                if (target.checked) {
                    selectedPaths.add(imagePath);
                } else {
                    selectedPaths.delete(imagePath);
                }
                updateSelectionInfo();
                scheduleStateSave();
                return;
            }

            // Handle select-all checkbox in table view
            if (target.id === 'select-all') {
                const filtered = imagesState.filter(matchesSearch);
                filtered.forEach(img => {
                    if (target.checked) {
                        selectedPaths.add(img.full_path);
                    } else {
                        selectedPaths.delete(img.full_path);
                    }
                });
                renderImages();
                updateSelectionInfo();
                return;
            }
        });

        // Browse files button handler
        document.getElementById('browse-files').addEventListener('click', () => {
            if (isElectron) {
                // Use Electron's native file dialog (via secure preload bridge)
                window.electronAPI.showOpenDialog({
                    properties: ['openFile', 'multiSelections'],
                    filters: [
                        { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'] },
                        { name: 'All Files', extensions: ['*'] }
                    ]
                }).then(result => {
                    if (!result.canceled) {
                        // Convert file paths to File objects and handle them
                        Promise.all(result.filePaths.map(filePath => {
                            return fetch(`file://${filePath}`)
                                .then(res => res.blob())
                                .then(blob => {
                                    const filename = filePath.split(/[\\\/]/).pop();
                                    return new File([blob], filename, { type: blob.type });
                                });
                        })).then(files => {
                            handleFiles(files);
                        });
                    }
                });
            } else {
                // Fallback to regular file input for web version
                fileInput.click();
            }
        });

        // Client-side image compression to reduce upload time and server load
        async function compressImage(file, maxDimension = 1920, quality = 0.85) {
            return new Promise((resolve, reject) => {
                // Skip compression for small files or GIFs (to preserve animation)
                if (file.size < 500 * 1024 || file.type === 'image/gif') {
                    resolve(file);
                    return;
                }

                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                img.onload = () => {
                    let { width, height } = img;

                    // Only resize if larger than max dimension
                    if (width > maxDimension || height > maxDimension) {
                        const ratio = Math.min(maxDimension / width, maxDimension / height);
                        width = Math.round(width * ratio);
                        height = Math.round(height * ratio);
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob((blob) => {
                        if (blob && blob.size < file.size) {
                            // Compression helped, use compressed version
                            resolve(new File([blob], file.name, { type: 'image/jpeg' }));
                        } else {
                            // Compression didn't help, use original
                            resolve(file);
                        }
                    }, 'image/jpeg', quality);
                };

                img.onerror = () => resolve(file); // On error, use original
                img.src = URL.createObjectURL(file);
            });
        }

        async function handleFiles(files) {
            // Validate files before upload
            const validFiles = [];
            const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/webp'];
            const maxSize = 10 * 1024 * 1024; // 10MB
            const errors = [];

            Array.from(files).forEach(file => {
                if (!allowedTypes.includes(file.type)) {
                    errors.push(`${file.name}: Unsupported file type. Please use JPG, PNG, GIF, BMP, or WebP.`);
                    return;
                }
                if (file.size > maxSize) {
                    errors.push(`${file.name}: File too large. Maximum size is 10MB.`);
                    return;
                }
                if (file.size === 0) {
                    errors.push(`${file.name}: Empty file.`);
                    return;
                }
                validFiles.push(file);
            });

            if (errors.length > 0) {
                alert('Some files were rejected:\\n\\n' + errors.join('\\n'));
            }

            if (validFiles.length === 0) {
                alert('No valid files to upload.');
                return;
            }

            // Compress images before upload (shows progress for large batches)
            const compressedFiles = await Promise.all(
                validFiles.map(file => compressImage(file))
            );

            const formData = new FormData();
            compressedFiles.forEach(file => formData.append('images', file));

            try {
                const response = await fetch('/upload', {method: 'POST', body: formData});
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Upload failed');
                }

                const existingPaths = new Set(imagesState.map(i=>i.full_path));
                data.images.filter(img => !existingPaths.has(img.full_path)).forEach(img => {
                    imagesState.push({ full_path: img.full_path, file_path: img.file_path, fields: { title:'', description:'', tags:'', category: currentProfile?.categories?.[0] || '' }, status: 'ready' });
                });
                renderImages();
                updateCostEstimate();
                scheduleStateSave();
            } catch (error) {
                alert('Upload failed: ' + error.message);
            }
        }

        function createGridCard(image) {
            const col = document.createElement('div');
            col.className = 'col-12 col-md-6 col-lg-4';
            const checked = selectedPaths.has(image.full_path) ? 'checked' : '';
            col.innerHTML = `
                <div class="image-card" data-image-path="${image.full_path}">
                    <div class="d-flex justify-content-between">
                        <div class="form-check">
                            <input class="form-check-input select-checkbox" type="checkbox" ${checked}>
                        </div>
                        <span class="badge ${image.status==='complete'?'text-bg-success':image.status==='processing'?'text-bg-info':image.status==='error'?'text-bg-danger':'text-bg-secondary'} status-badge">${(image.status||'ready')[0].toUpperCase()+ (image.status||'ready').slice(1)}</span>
                    </div>
                    <button class="btn btn-sm btn-outline-danger delete-btn"></button>
                    <img src="${image.full_path}" class="thumb mb-3" alt="uploaded image" loading="lazy">
                    <div class="metadata-fields">
                        ${createMetadataFields(currentProfile, image.fields)}
                    </div>
                    <div class="d-flex justify-content-between align-items-center mt-2">
                        <button class="btn btn-sm generate-single">Regenerate</button>
                        <span class="text-muted small">Editable before export</span>
                    </div>
                </div>`;

            const card = col.querySelector('.image-card');

            // bind inputs (still needed for form field syncing)
            syncInputsToState(card, image);

            // processing/complete styles
            if (image.status==='processing') card.classList.add('processing');
            if (image.status==='complete') card.classList.add('complete');

            return col;
        }

        function createListItem(image) {
            const item = document.createElement('div');
            item.className = 'list-item';
            const statusClass = image.status==='complete' ? 'status-complete' : image.status==='processing' ? 'status-processing' : image.status==='error' ? 'status-error' : 'status-ready';
            item.dataset.imagePath = image.full_path;
            item.innerHTML = `
                <div class="list-left">
                    <input type="checkbox" class="form-check-input select-checkbox" ${selectedPaths.has(image.full_path)?'checked':''}>
                    <div class="list-thumb"><img src="${image.full_path}" alt="thumb" loading="lazy"></div>
                </div>
                <div class="list-main">
                    <div class="list-file small text-muted">
                        <span class="status-dot ${statusClass}"></span>
                        <span class="filename" title="${image.full_path.split('/').pop()}">${image.full_path.split('/').pop()}</span>
                    </div>
                    <div class="list-fields">
                        <input type="text" class="form-control title-input" placeholder="Title" value="${image.fields.title||''}">
                        <textarea class="form-control description-input" placeholder="Description">${image.fields.description||''}</textarea>
                        <input type="text" class="form-control tags-input" placeholder="Tags" value="${image.fields.tags||''}">
                        <select class="form-select category-input">${generateCategoryOptions(currentProfile.categories, image.fields.category||'')}</select>
                    </div>
                </div>
                <div class="list-right">
                    <button class="btn btn-outline-primary btn-compact regenerate" title="Regenerate" aria-label="Regenerate">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.75 6h-2.06A6 6 0 1 1 12 6c1.66 0 3.14.69 4.22 1.78L14 10h6V4l-2.35 2.35z"/></svg>
                    </button>
                    <button class="btn btn-outline-danger btn-compact delete" title="Delete" aria-label="Delete">
                        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M6 7h12l-1 12a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2L6 7zm5-3h2a1 1 0 0 1 1 1v1h4v2H4V6h4V5a1 1 0 0 1 1-1z"/></svg>
                    </button>
                </div>
            `;

            // sync inputs (still needed for form field syncing)
            syncInputsToState(item, image);

            return item;
        }

        function queueGeneration(paths) {
            if (!checkApiKey()) return;

            // Start progress tracker for batches > 1
            if (paths.length > 1) {
                progressTracker.start(paths.length);
            }

            paths.forEach(p => {
                // Skip if cancelled
                if (progressTracker.cancelled) return;

                const img = getImageByPath(p);
                if (!img) return;
                socket.emit('generate_metadata', {
                    full_path: p,
                    profile: document.getElementById('profile-select').value,
                    settings: { apiKey: localStorage.getItem('openai-key') || '' }
                });
            });
        }

        // Socket.io handlers
        let processingCount = 0;
        
        function updateProgress() {
            const btn = document.getElementById('generate-all');
            btn.textContent = processingCount > 0 
                ? `Processing (${processingCount} remaining)` 
                : 'Generate All Metadata';
            btn.disabled = processingCount > 0;
        }

        function updateSelectionInfo() {
            document.getElementById('selection-info').textContent = `${selectedPaths.size} selected`;
            const hasSelection = selectedPaths.size > 0;
            document.getElementById('generate-selected').disabled = !hasSelection;
            document.getElementById('delete-selected').disabled = !hasSelection;
        }

        socket.on('processing_start', (data) => {
            const card = document.querySelector(`[data-image-path="${data.image}"]`);
            if (card) {
                processingCount++;
                updateProgress();
                card.classList.add('processing');
                card.classList.remove('complete');
                const badge = card.querySelector('.status-badge');
                if (badge) { badge.className = 'badge text-bg-info status-badge'; badge.textContent = 'Processing'; }
            }
            const item = getImageByPath(data.image);
            if (item) { item.status = 'processing'; if (viewMode==='table' || viewMode==='list') renderImages(); }
        });

        socket.on('metadata_update', (data) => {
            const card = document.querySelector(`[data-image-path="${data.image}"]`);
            if (card && currentProfile) {
                processingCount--;
                updateProgress();
                progressTracker.complete();
                currentProfile.required_fields.forEach(field => {
                    const input = card.querySelector(`.${field}-input`);
                    if (input) input.value = data.metadata[field] || '';
                });
                card.classList.add('complete');
                card.classList.remove('processing');
                const badge = card.querySelector('.status-badge');
                if (badge) {
                    // Show "Cached" badge if response was from cache
                    if (data.cached) {
                        badge.className = 'badge text-bg-info status-badge';
                        badge.textContent = 'Cached';
                    } else {
                        badge.className = 'badge text-bg-success status-badge';
                        badge.textContent = 'Complete';
                    }
                }

                // Show notification when all processing is done
                if (processingCount === 0 && isElectron && window.showElectronNotification) {
                    window.showElectronNotification('MetaData Refiner', 'All metadata generation completed!');
                }
            }
            // Update state
            const item = getImageByPath(data.image);
            if (item) {
                item.status = 'complete';
                item.fields = { ...item.fields, ...data.metadata };
                if (viewMode==='table' || viewMode==='list') renderImages();
                scheduleStateSave();
            }
        });

        socket.on('error', (data) => {
            processingCount--;
            updateProgress();
            progressTracker.complete(); // Count errors as completed for progress tracking
            // Show categorized error toast instead of alert
            showToast(data);
            const item = getImageByPath(data.image);
            if (item) { item.status = 'error'; if (viewMode==='table' || viewMode==='list') renderImages(); }
        });

        // Export handling
        document.getElementById('generate-all').addEventListener('click', () => {
            queueGeneration(imagesState.map(i=>i.full_path));
        });

        document.getElementById('generate-selected').addEventListener('click', () => {
            queueGeneration(Array.from(selectedPaths));
        });

        document.getElementById('delete-selected').addEventListener('click', () => {
            imagesState = imagesState.filter(i=>!selectedPaths.has(i.full_path));
            selectedPaths.clear();
            renderImages();
            updateSelectionInfo();
            updateCostEstimate();
            scheduleStateSave();
        });

        document.getElementById('cancel-batch').addEventListener('click', () => {
            progressTracker.cancel();
            // Reset any processing images back to ready state
            imagesState.forEach(img => {
                if (img.status === 'processing') {
                    img.status = 'ready';
                }
            });
            renderImages();
        });

        document.getElementById('export').addEventListener('click', async () => {
            const metadata = imagesState.map(img => {
                const obj = { full_path: img.full_path };
                currentProfile.required_fields.forEach(f=>{ obj[f] = img.fields[f] || ''; });
                return obj;
            });

            try {
                const response = await fetch('/export', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        data: metadata,
                        profile: document.getElementById('profile-select').value,
                        base_path: localStorage.getItem('base-path') || ''
                    })
                });
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'metadata.csv';
                a.click();
                a.remove();
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        });
    </script>
</body>
</html>
