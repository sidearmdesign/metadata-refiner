<!DOCTYPE html>
<html>
<head>
    <title>MetaData Refiner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@400;500;600;700&family=DM+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <link rel="stylesheet" href="/static/css/main.css">
</head>
<body>
    <!-- Toast notification container -->
    <div id="toast-container"></div>

    <!-- Full-page drop overlay -->
    <div id="drop-overlay" class="drop-overlay">
        <div class="drop-overlay-content">
            <svg viewBox="0 0 24 24" width="64" height="64">
                <path fill="currentColor" d="M12 3c.26 0 .52.1.71.29l5 5a1 1 0 1 1-1.42 1.42L13 6.41V16a1 1 0 1 1-2 0V6.41L7.71 9.71A1 1 0 0 1 6.29 8.29l5-5A1 1 0 0 1 12 3z"/>
                <path fill="currentColor" d="M5 18a1 1 0 1 0 0 2h14a1 1 0 1 0 0-2H5z"/>
            </svg>
            <span class="drop-overlay-text">DROP FILES ANYWHERE</span>
        </div>
    </div>

    <div class="app-shell" id="app-dropzone">
        <!-- Header Bar -->
        <header class="header-bar">
            <div class="header-left">
                <div class="brand" aria-label="MetaData Refiner">
                    <div class="logo-mark"></div>
                    <span class="logo-text">METADATA REFINER</span>
                </div>
            </div>
            <div class="header-center">
                <label class="field-label">PROFILE</label>
                <select id="profile-select" class="profile-select"></select>

                <div class="header-divider"></div>

                <div class="view-toggle" role="group" aria-label="View mode">
                    <input type="radio" name="view-mode" id="view-grid" value="grid">
                    <label for="view-grid">GRID</label>
                    <input type="radio" name="view-mode" id="view-list" value="list">
                    <label for="view-list">LIST</label>
                    <input type="radio" name="view-mode" id="view-table" value="table">
                    <label for="view-table">TABLE</label>
                </div>

                <div class="header-divider"></div>

                <input id="search-input" type="text" class="header-search" placeholder="Search...">
            </div>
            <div class="header-right">
                <button id="settings-btn" class="btn-icon" title="Settings">
                    <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                </button>
            </div>
        </header>

        <!-- Main Content - Full Width Image Grid -->
        <main class="main-content">
            <section id="image-grid" class="image-grid"></section>

            <!-- Floating Drop Zone -->
            <div id="drop-zone" class="drop-zone-floating">
                <div class="drop-icon">
                    <svg viewBox="0 0 24 24" width="24" height="24">
                        <path fill="currentColor" d="M12 3c.26 0 .52.1.71.29l5 5a1 1 0 1 1-1.42 1.42L13 6.41V16a1 1 0 1 1-2 0V6.41L7.71 9.71A1 1 0 0 1 6.29 8.29l5-5A1 1 0 0 1 12 3z"/>
                        <path fill="currentColor" d="M5 18a1 1 0 1 0 0 2h14a1 1 0 1 0 0-2H5z"/>
                    </svg>
                </div>
                <span class="drop-text">DROP FILES</span>
                <input type="file" id="file-input" multiple accept="image/*" hidden>
                <button id="browse-files" class="btn btn-secondary btn-sm">BROWSE</button>
            </div>
        </main>

        <!-- Control Panel (Bottom) -->
        <div id="control-panel" class="control-panel">
            <div class="control-panel-inner">
                <!-- Stats & Progress (Left) -->
                <div class="stats-panel">
                    <div class="stat-item">
                        <span class="stat-label">SELECTED</span>
                        <span class="stat-value" id="selection-info">0</span>
                    </div>
                    <div class="stat-item" id="cost-estimate" style="display: none;">
                        <span class="stat-label">EST. COST</span>
                        <span class="stat-value"><span id="fresh-cost">$0.00</span> / <span id="cached-cost">$0.00</span></span>
                    </div>
                    <!-- Batch Progress -->
                    <div id="batch-progress" class="progress-panel" style="display: none;">
                        <div class="progress-header">
                            <span class="progress-label">PROCESSING <strong id="progress-current">0</strong> OF <span id="progress-total">0</span></span>
                            <span class="progress-eta" id="progress-eta"></span>
                        </div>
                        <div class="progress-track">
                            <div class="progress-fill" id="progress-bar"></div>
                        </div>
                        <button id="cancel-batch" class="btn btn-secondary btn-sm">CANCEL</button>
                    </div>
                </div>

                <!-- Action Buttons (Right) -->
                <div class="action-buttons">
                    <button id="generate-all" class="btn btn-primary" disabled>
                        <span>GENERATE ALL</span>
                    </button>
                    <button id="generate-selected" class="btn btn-secondary" disabled>
                        <span>GENERATE SELECTED</span>
                    </button>
                    <button id="export" class="btn btn-primary" disabled>
                        <span>EXPORT CSV</span>
                    </button>
                    <button id="delete-selected" class="btn btn-danger" disabled>
                        <span>DELETE SELECTED</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay" style="display: none;">
        <div class="modal-container">
            <div class="modal-header">
                <h2 class="modal-title">SETTINGS</h2>
                <button type="button" class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="field-label" for="api-key">OPENAI API KEY</label>
                    <input type="password" class="field-input" id="api-key" placeholder="sk-...">
                    <span class="field-hint">Key is stored in browser localStorage. Alternatively, set OPENAI_API_KEY in your .env file.</span>
                </div>
                <div class="form-group">
                    <label class="field-label" for="base-path">BASE PATH FOR CSV EXPORT</label>
                    <input type="text" class="field-input" id="base-path" placeholder="e.g., C:/Users/MyName/Pictures">
                    <span class="field-hint">If provided, this path will be prepended to image paths in CSV exports.</span>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-cost-estimate" checked>
                        <span class="checkbox-mark"></span>
                        <span>Show Cost Estimates</span>
                    </label>
                </div>

                <div class="settings-divider"></div>

                <div class="form-group">
                    <label class="field-label">APPEARANCE</label>
                    <div class="settings-row">
                        <span>Dark Mode</span>
                        <button id="theme-toggle-setting" class="btn btn-secondary btn-sm" onclick="toggleTheme()">TOGGLE</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="field-label">PROFILES</label>
                    <div class="settings-row">
                        <span>Manage metadata profiles</span>
                        <button class="btn btn-secondary btn-sm" onclick="closeSettings(); openProfilePanel();">MANAGE</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeSettings()">CANCEL</button>
                <button type="button" class="btn btn-primary" onclick="saveSettings()">SAVE</button>
            </div>
        </div>
    </div>

    <!-- Profile Management Slide Panel -->
    <div class="slide-panel-overlay" id="profilePanelOverlay" onclick="closeProfilePanel()"></div>
    <div class="slide-panel" id="profilePanel">
        <div class="slide-panel-header">
            <h2 class="panel-title">PROFILE MANAGEMENT</h2>
            <button class="btn-icon" onclick="closeProfilePanel()" title="Close">
                <svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
            </button>
        </div>
        <div class="slide-panel-content">
            <!-- Profile List -->
            <div class="profile-list" id="profileList">
                <!-- Populated dynamically -->
            </div>

            <button class="btn btn-primary btn-full" onclick="showNewProfileForm()">
                + NEW PROFILE
            </button>

            <!-- Profile Form (hidden by default) -->
            <div class="profile-form" id="profileForm" style="display: none;">
                <input type="hidden" id="editingProfileId">

                <div class="form-field">
                    <label class="field-label">PROFILE NAME</label>
                    <input type="text" class="field-input" id="profileNameInput" placeholder="My Custom Profile">
                </div>

                <div class="form-field">
                    <label class="field-label">AI PROMPT</label>
                    <textarea class="field-textarea" id="profilePromptInput" rows="10" placeholder="Instructions for the AI to generate metadata..."></textarea>
                </div>

                <div class="form-field">
                    <label class="field-label">REQUIRED FIELDS</label>
                    <div class="dynamic-list" id="requiredFieldsList">
                        <!-- Dynamic field items -->
                    </div>
                    <button class="btn btn-secondary btn-sm" onclick="addRequiredField()">+ ADD FIELD</button>
                </div>

                <div class="form-field">
                    <label class="field-label">CATEGORIES</label>
                    <textarea class="field-textarea" id="profileCategoriesInput" rows="3" placeholder="Category 1, Category 2, Category 3..."></textarea>
                    <span class="field-hint">Comma-separated list of categories</span>
                </div>

                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="cancelProfileForm()">CANCEL</button>
                    <button class="btn btn-primary" onclick="saveProfile()">SAVE PROFILE</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Theme management
        function applyTheme(isDark) {
            document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
            localStorage.setItem('dark-mode', isDark);
        }

        function toggleTheme() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            applyTheme(!isDark);
        }

        // Control panel toggle
        function toggleControlPanel() {
            const panel = document.getElementById('control-panel');
            const toggle = document.getElementById('controls-toggle');
            const isCollapsed = panel.classList.toggle('collapsed');
            toggle.querySelector('.toggle-icon').textContent = isCollapsed ? '▶' : '▼';
        }

        // Settings handling
        function showSettings() {
            document.getElementById('api-key').value = localStorage.getItem('openai-key') || '';
            document.getElementById('base-path').value = localStorage.getItem('base-path') || '';
            document.getElementById('show-cost-estimate').checked = localStorage.getItem('show-cost-estimate') !== 'false';
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettings() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        function saveSettings() {
            const key = document.getElementById('api-key').value.trim();
            const showCostEstimate = document.getElementById('show-cost-estimate').checked;
            const basePath = document.getElementById('base-path').value.trim();

            if (key) {
                localStorage.setItem('openai-key', key);
            }
            localStorage.setItem('show-cost-estimate', showCostEstimate);
            localStorage.setItem('base-path', basePath);

            document.getElementById('cost-estimate').style.display =
                showCostEstimate ? 'flex' : 'none';

            closeSettings();
            updateCostEstimate();
        }

        // Profile Management Functions
        function openProfilePanel() {
            document.getElementById('profilePanel').classList.add('open');
            document.getElementById('profilePanelOverlay').classList.add('visible');
            renderProfileList();
        }

        function closeProfilePanel() {
            document.getElementById('profilePanel').classList.remove('open');
            document.getElementById('profilePanelOverlay').classList.remove('visible');
            cancelProfileForm();
        }

        function renderProfileList() {
            const list = document.getElementById('profileList');
            list.innerHTML = '';

            Object.entries(profilesConfig).forEach(([id, profile]) => {
                const item = document.createElement('div');
                item.className = 'profile-list-item';
                item.innerHTML = `
                    <span class="profile-name">${profile.name}</span>
                    <button class="btn btn-secondary btn-sm" onclick="editProfile('${id}')">EDIT</button>
                `;
                list.appendChild(item);
            });
        }

        function showNewProfileForm() {
            document.getElementById('editingProfileId').value = '';
            document.getElementById('profileNameInput').value = '';
            document.getElementById('profilePromptInput').value = '';
            document.getElementById('profileCategoriesInput').value = '';

            // Clear and add default fields
            const fieldsList = document.getElementById('requiredFieldsList');
            fieldsList.innerHTML = '';
            ['title', 'description', 'tags', 'category'].forEach(f => addRequiredField(f));

            document.getElementById('profileForm').style.display = 'block';
        }

        function editProfile(profileId) {
            const profile = profilesConfig[profileId];
            if (!profile) return;

            document.getElementById('editingProfileId').value = profileId;
            document.getElementById('profileNameInput').value = profile.name || '';
            document.getElementById('profilePromptInput').value = profile.prompt || '';
            document.getElementById('profileCategoriesInput').value = (profile.categories || []).join(', ');

            // Populate required fields
            const fieldsList = document.getElementById('requiredFieldsList');
            fieldsList.innerHTML = '';
            (profile.required_fields || []).forEach(f => addRequiredField(f));

            document.getElementById('profileForm').style.display = 'block';
        }

        function addRequiredField(value = '') {
            const list = document.getElementById('requiredFieldsList');
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `
                <input type="text" class="field-input required-field-input" value="${value}" placeholder="field_name">
                <button class="btn-icon" onclick="this.parentElement.remove()" title="Remove">
                    <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            `;
            list.appendChild(item);
        }

        function getRequiredFields() {
            const inputs = document.querySelectorAll('#requiredFieldsList .required-field-input');
            return Array.from(inputs).map(i => i.value.trim().toLowerCase().replace(/\s+/g, '_')).filter(v => v);
        }

        function cancelProfileForm() {
            document.getElementById('profileForm').style.display = 'none';
            document.getElementById('editingProfileId').value = '';
        }

        async function saveProfile() {
            const profileId = document.getElementById('editingProfileId').value;
            const name = document.getElementById('profileNameInput').value.trim();
            const prompt = document.getElementById('profilePromptInput').value.trim();
            const requiredFields = getRequiredFields();
            const categoriesText = document.getElementById('profileCategoriesInput').value;
            const categories = categoriesText.split(',').map(c => c.trim()).filter(c => c);

            if (!name) {
                alert('Profile name is required');
                return;
            }

            if (requiredFields.length === 0) {
                alert('At least one required field is needed');
                return;
            }

            const profileData = {
                name,
                prompt,
                required_fields: requiredFields,
                categories
            };

            const url = profileId ? `/api/profiles/${profileId}` : '/api/profiles';
            const method = profileId ? 'PUT' : 'POST';

            try {
                const response = await fetch(url, {
                    method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(profileData)
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to save profile');
                }

                // Update local state
                profilesConfig[result.id] = result.profile;

                // Also save to localStorage as backup
                localStorage.setItem('profiles_backup', JSON.stringify(profilesConfig));

                // Refresh UI
                renderProfileList();
                populateProfileDropdown();
                cancelProfileForm();

                // Show success notification
                showToast({
                    title: 'Success',
                    message: profileId ? 'Profile updated successfully' : 'Profile created successfully',
                    category: 'success'
                });
            } catch (error) {
                console.error('Failed to save profile:', error);
                alert('Failed to save profile: ' + error.message);
            }
        }

        function populateProfileDropdown() {
            const profileSelect = document.getElementById('profile-select');
            const currentValue = profileSelect.value;
            profileSelect.innerHTML = Object.entries(profilesConfig).map(([id, profile]) =>
                `<option value="${id}">${profile.name}</option>`
            ).join('');
            // Restore selection if still valid
            if (profilesConfig[currentValue]) {
                profileSelect.value = currentValue;
            }
        }

        function checkApiKey() {
            // Allow processing to proceed - the server will check .env first,
            // then fall back to localStorage if needed
            const hasLocalKey = !!localStorage.getItem('openai-key');
            // Note: We can't check server-side .env from frontend, so we'll let
            // the server handle the API key resolution and show error if needed
            return true; // Always return true, let server handle the validation
        }

        // Cost estimation
        function updateCostEstimate() {
            const imageCount = document.querySelectorAll('.image-card').length;
            if (imageCount === 0) {
                document.getElementById('fresh-cost').textContent = '$0.00';
                document.getElementById('cached-cost').textContent = '$0.00';
                return;
            }

            // Estimate tokens per image
            const inputTokensPerImage = 25000; // system prompt + base64 image
            const outputTokensPerImage = 100; // JSON response

            // Calculate costs for GPT-5-nano
            const inputCostPerMillion = 0.05; // $0.05 per million tokens
            const cachedCostPerMillion = 0.005; // $0.005 per million tokens (90% discount)
            const outputCostPerMillion = 0.40; // $0.40 per million tokens

            const totalInputTokens = inputTokensPerImage * imageCount;
            const totalOutputTokens = outputTokensPerImage * imageCount;

            const freshCost = 
                (totalInputTokens / 1000000 * inputCostPerMillion) +
                (totalOutputTokens / 1000000 * outputCostPerMillion);
            
            const cachedCost = 
                (totalInputTokens / 1000000 * cachedCostPerMillion) +
                (totalOutputTokens / 1000000 * outputCostPerMillion);

            document.getElementById('fresh-cost').textContent = 
                `$${freshCost.toFixed(4)}`;
            document.getElementById('cached-cost').textContent = 
                `$${cachedCost.toFixed(4)}`;
        }

        // Detect if running in Electron (via preload script)
        const isElectron = window.electronAPI && window.electronAPI.isElectron;

        // Add API key to all fetch requests
        const originalFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            options.headers = options.headers || {};
            options.headers['X-OpenAI-Key'] = localStorage.getItem('openai-key') || '';
            return originalFetch(url, options);
        };

        const socket = io();

        // Electron-specific functionality (uses secure preload bridge)
        if (isElectron) {
            // Listen for files selected from menu
            window.electronAPI.onFilesSelected((filePaths) => {
                // Convert file paths to File objects and handle them
                Promise.all(filePaths.map(filePath => {
                    return fetch(`file://${filePath}`)
                        .then(res => res.blob())
                        .then(blob => {
                            const filename = filePath.split(/[\\\/]/).pop();
                            return new File([blob], filename, { type: blob.type });
                        });
                })).then(files => {
                    handleFiles(files);
                });
            });

            // Show notification when processing completes
            window.showElectronNotification = function(title, body) {
                window.electronAPI.showNotification(title, body);
            };
        }
        let currentProfile = null;
        let profilesConfig = {};
        // Centralized state for scalable rendering
        let imagesState = []; // [{full_path, file_path?, fields:{}, status:'ready'|'processing'|'complete'|'error'}]
        let selectedPaths = new Set();
        let viewMode = localStorage.getItem('view-mode') || 'grid';
        let searchQuery = '';

        // Helper functions

        // Toast notification for categorized errors
        function showToast(data) {
            const container = document.getElementById('toast-container');
            const categories = {
                auth: 'error',
                quota: 'processing',
                timeout: 'ready',
                network: 'ready',
                model: 'ready',
                server: 'ready'
            };
            const statusClass = categories[data.category] || 'ready';
            const filename = data.image ? data.image.split('/').pop() : 'Unknown';

            const toast = document.createElement('div');
            toast.className = `toast ${statusClass}`;
            toast.setAttribute('role', 'alert');
            toast.innerHTML = `
                <div class="toast-header">
                    <span class="status-dot ${statusClass}"></span>
                    <strong class="toast-title">${data.title || 'ERROR'}</strong>
                    <span class="toast-file">${filename}</span>
                    <button type="button" class="toast-close" onclick="this.closest('.toast').remove()">&times;</button>
                </div>
                <div class="toast-body">
                    <p class="toast-message">${data.message || 'An error occurred'}</p>
                    ${data.action ? `<p class="toast-action">${data.action}</p>` : ''}
                    ${data.retry_allowed && data.image ? `<button class="btn-secondary btn-sm" onclick="retryImage('${data.image}'); this.closest('.toast').remove();">RETRY</button>` : ''}
                </div>
            `;
            container.appendChild(toast);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.classList.add('fade-out');
                    setTimeout(() => toast.remove(), 300);
                }
            }, 10000);
        }

        // Retry a single image
        function retryImage(imagePath) {
            const item = getImageByPath(imagePath);
            if (item) {
                item.status = 'ready';
                queueGeneration([imagePath]);
            }
        }

        function generateCategoryOptions(categories, selectedValue) {
            return categories.map(cat => 
                `<option value="${cat}" ${cat === selectedValue ? 'selected' : ''}>${cat}</option>`
            ).join('');
        }

        function createMetadataFields(profile, imageData = {}) {
            return profile.required_fields.map(field => {
                const value = imageData[field] || '';
                if (field === 'category') {
                    return `
                        <div class="mb-3">
                            <label>Category</label>
                            <select class="form-select category-input">
                                ${generateCategoryOptions(profile.categories, value)}
                            </select>
                        </div>`;
                }
                return `
                    <div class="mb-3">
                        <label>${field.charAt(0).toUpperCase() + field.slice(1)}</label>
                        ${field === 'description' ? 
                            `<textarea class="form-control ${field}-input">${value}</textarea>` :
                            `<input type="text" class="form-control ${field}-input" value="${value}">`}
                    </div>`;
            }).join('');
        }

        function updateAllCards() { renderImages(); }

        function getImageByPath(path) {
            return imagesState.find(img => img.full_path === path);
        }

        function syncInputsToState(card, image) {
            currentProfile.required_fields.forEach(field => {
                const input = card.querySelector(`.${field}-input`);
                if (!input) return;
                const handler = () => {
                    image.fields[field] = input.value;
                };
                input.addEventListener('input', handler);
                // Initialize from state if present
                if (image.fields[field]) input.value = image.fields[field];
            });
            // Category select
            const sel = card.querySelector('.category-input');
            if (sel) {
                sel.addEventListener('change', () => { image.fields['category'] = sel.value; });
                if (image.fields['category']) sel.value = image.fields['category'];
            }
        }

        function matchesSearch(image) {
            if (!searchQuery) return true;
            const q = searchQuery.toLowerCase();
            const fields = Object.values(image.fields || {}).join(' ').toLowerCase();
            return image.full_path.toLowerCase().includes(q) || fields.includes(q);
        }

        // Lazy loading configuration
        const BATCH_SIZE = 20;
        let renderedCount = 0;
        let scrollObserver = null;

        // Session state persistence
        const SESSION_KEY = 'mdr-session-state';
        const SESSION_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

        function saveSessionState() {
            const state = {
                images: imagesState,
                selectedPaths: Array.from(selectedPaths),
                profile: document.getElementById('profile-select')?.value || 'zedge',
                viewMode: viewMode,
                timestamp: Date.now()
            };
            try {
                localStorage.setItem(SESSION_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save session state:', e);
            }
        }

        function loadSessionState() {
            try {
                const saved = localStorage.getItem(SESSION_KEY);
                if (!saved) return null;

                const state = JSON.parse(saved);
                // Check if expired
                if (Date.now() - state.timestamp > SESSION_EXPIRY) {
                    localStorage.removeItem(SESSION_KEY);
                    return null;
                }
                return state;
            } catch (e) {
                console.warn('Could not load session state:', e);
                return null;
            }
        }

        function clearSessionState() {
            localStorage.removeItem(SESSION_KEY);
        }

        // Auto-save on state changes (debounced)
        let saveTimeout = null;
        function scheduleStateSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveSessionState, 1000);
        }

        // Progress tracker for batch processing
        const progressTracker = {
            total: 0,
            completed: 0,
            startTime: null,
            times: [],
            cancelled: false,

            start(total) {
                this.total = total;
                this.completed = 0;
                this.startTime = Date.now();
                this.times = [];
                this.cancelled = false;
                document.getElementById('batch-progress').style.display = 'block';
                this.update();
            },

            complete() {
                this.times.push(Date.now());
                this.completed++;
                this.update();

                if (this.completed >= this.total) {
                    setTimeout(() => {
                        document.getElementById('batch-progress').style.display = 'none';
                    }, 2000);
                }
            },

            cancel() {
                this.cancelled = true;
                document.getElementById('batch-progress').style.display = 'none';
            },

            update() {
                const pct = this.total > 0 ? Math.round((this.completed / this.total) * 100) : 0;
                document.getElementById('progress-bar').style.width = `${pct}%`;
                document.getElementById('progress-current').textContent = this.completed;
                document.getElementById('progress-total').textContent = this.total;

                // Calculate ETA
                if (this.times.length > 0 && this.completed < this.total) {
                    const avgTime = (this.times[this.times.length - 1] - this.startTime) / this.completed;
                    const remaining = Math.round((this.total - this.completed) * avgTime / 1000);
                    const mins = Math.floor(remaining / 60);
                    const secs = remaining % 60;
                    document.getElementById('progress-eta').textContent =
                        mins > 0 ? `~${mins}m ${secs}s left` : `~${secs}s left`;
                } else {
                    document.getElementById('progress-eta').textContent = '';
                }
            }
        };

        function renderImages() {
            const grid = document.getElementById('image-grid');
            grid.innerHTML = '';
            renderedCount = 0;

            // Clean up previous observer
            if (scrollObserver) {
                scrollObserver.disconnect();
                scrollObserver = null;
            }

            const filtered = imagesState.filter(matchesSearch);

            // Clear all view classes first
            grid.classList.remove('image-grid', 'table-view', 'list-view');

            if (viewMode === 'table') {
                grid.classList.add('table-view');

                const table = document.createElement('table');
                table.className = 'data-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th class="col-select"><input type="checkbox" id="select-all"></th>
                            <th class="col-image">IMAGE</th>
                            <th class="col-title">TITLE</th>
                            <th class="col-desc">DESCRIPTION</th>
                            <th class="col-tags">TAGS</th>
                            <th class="col-cat">CATEGORY</th>
                            <th class="col-status">STATUS</th>
                            <th class="col-actions">ACTIONS</th>
                        </tr>
                    </thead>
                    <tbody></tbody>`;
                const tbody = table.querySelector('tbody');

                filtered.forEach(image => {
                    const tr = document.createElement('tr');
                    tr.dataset.imagePath = image.full_path;
                    const statusClass = image.status === 'complete' ? 'complete' :
                                       image.status === 'processing' ? 'processing' :
                                       image.status === 'error' ? 'error' : 'ready';
                    tr.innerHTML = `
                        <td class="col-select">
                            <label class="checkbox-label">
                                <input type="checkbox" class="row-select" ${selectedPaths.has(image.full_path)?'checked':''}>
                                <span class="checkbox-mark"></span>
                            </label>
                        </td>
                        <td class="col-image">
                            <div class="table-thumb">
                                <img src="${image.full_path}" alt="thumb" loading="lazy">
                            </div>
                            <span class="filename">${image.full_path.split('/').pop()}</span>
                        </td>
                        <td class="col-title"><input type="text" class="field-input title-input" value="${image.fields.title||''}"></td>
                        <td class="col-desc"><textarea class="field-input description-input">${image.fields.description||''}</textarea></td>
                        <td class="col-tags"><input type="text" class="field-input tags-input" value="${image.fields.tags||''}"></td>
                        <td class="col-cat">
                            <select class="field-select category-input">
                                ${generateCategoryOptions(currentProfile.categories, image.fields.category||'')}
                            </select>
                        </td>
                        <td class="col-status">
                            <span class="status-dot ${statusClass}"></span>
                            <span class="status-text">${(image.status||'ready').toUpperCase()}</span>
                        </td>
                        <td class="col-actions">
                            <button class="btn-icon regenerate" title="Regenerate">
                                <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.75 6h-2.06A6 6 0 1 1 12 6c1.66 0 3.14.69 4.22 1.78L14 10h6V4l-2.35 2.35z"/></svg>
                            </button>
                            <button class="btn-icon delete" title="Delete">
                                <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                            </button>
                        </td>`;
                    tbody.appendChild(tr);
                    syncInputsToState(tr, image);
                });

                grid.appendChild(table);

                const selectAll = table.querySelector('#select-all');
                if (selectAll) {
                    selectAll.checked = filtered.length > 0 && filtered.every(img => selectedPaths.has(img.full_path));
                }
            } else if (viewMode === 'grid') {
                grid.classList.add('image-grid');

                // Use lazy loading for grid view with many images
                if (filtered.length > BATCH_SIZE) {
                    const initialBatch = filtered.slice(0, BATCH_SIZE);
                    initialBatch.forEach(img => grid.appendChild(createGridCard(img)));
                    renderedCount = initialBatch.length;

                    if (renderedCount < filtered.length) {
                        const sentinel = document.createElement('div');
                        sentinel.className = 'scroll-sentinel';
                        sentinel.innerHTML = '<div class="loading-spinner"></div><span>Loading more...</span>';
                        grid.appendChild(sentinel);

                        scrollObserver = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting && renderedCount < filtered.length) {
                                sentinel.remove();
                                const nextBatch = filtered.slice(renderedCount, renderedCount + BATCH_SIZE);
                                nextBatch.forEach(img => grid.appendChild(createGridCard(img)));
                                renderedCount += nextBatch.length;
                                if (renderedCount < filtered.length) {
                                    grid.appendChild(sentinel);
                                }
                            }
                        }, { rootMargin: '100px' });

                        scrollObserver.observe(sentinel);
                    }
                } else {
                    filtered.forEach(img => grid.appendChild(createGridCard(img)));
                }
            } else if (viewMode === 'list') {
                grid.classList.add('list-view');
                filtered.forEach(img => grid.appendChild(createListItem(img)));
            }

            // Enable/disable action buttons
            document.getElementById('generate-selected').disabled = selectedPaths.size === 0;
            document.getElementById('delete-selected').disabled = selectedPaths.size === 0;
            document.getElementById('export').disabled = imagesState.length === 0;
            document.getElementById('generate-all').disabled = imagesState.length === 0 || processingCount>0;
            updateSelectionInfo();
        }

        // Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize theme
            const darkMode = localStorage.getItem('dark-mode') === 'true';
            applyTheme(darkMode);

            // Header button event listeners
            document.getElementById('settings-btn').addEventListener('click', showSettings);

            // Close modal on overlay click
            document.getElementById('settings-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) closeSettings();
            });

            const response = await fetch('/api/profiles');
            const data = await response.json();
            profilesConfig = data.profiles;

            const profileSelect = document.getElementById('profile-select');
            profileSelect.innerHTML = Object.entries(profilesConfig).map(([id, profile]) =>
                `<option value="${id}">${profile.name}</option>`
            ).join('');

            profileSelect.value = data.default_profile;
            currentProfile = profilesConfig[data.default_profile];

            profileSelect.addEventListener('change', () => {
                currentProfile = profilesConfig[profileSelect.value];
                updateAllCards();
                scheduleStateSave();
            });

            // Session recovery - check for saved state
            const savedState = loadSessionState();
            if (savedState && savedState.images && savedState.images.length > 0) {
                const timeAgo = Math.round((Date.now() - savedState.timestamp) / 60000);
                const timeStr = timeAgo < 60 ? `${timeAgo} minutes` : `${Math.round(timeAgo / 60)} hours`;

                if (confirm(`Found ${savedState.images.length} images from ${timeStr} ago. Restore session?`)) {
                    imagesState = savedState.images;
                    selectedPaths = new Set(savedState.selectedPaths || []);
                    if (savedState.profile && profilesConfig[savedState.profile]) {
                        profileSelect.value = savedState.profile;
                        currentProfile = profilesConfig[savedState.profile];
                    }
                    if (savedState.viewMode) {
                        viewMode = savedState.viewMode;
                    }
                    renderImages();
                    updateCostEstimate();
                } else {
                    clearSessionState();
                }
            }

            // Initialize cost estimate display
            const showCostEstimate = localStorage.getItem('show-cost-estimate') !== 'false';
            document.getElementById('cost-estimate').style.display =
                showCostEstimate ? 'flex' : 'none';

            // View mode setup
            document.getElementById('view-grid').checked = viewMode === 'grid';
            const listRadio = document.getElementById('view-list');
            const tableRadio = document.getElementById('view-table');
            listRadio.checked = viewMode === 'list';
            tableRadio.checked = viewMode === 'table';
            document.getElementById('view-grid').addEventListener('change', ()=>{ viewMode='grid'; localStorage.setItem('view-mode','grid'); renderImages(); });
            listRadio.addEventListener('change', ()=>{ viewMode='list'; localStorage.setItem('view-mode','list'); renderImages(); });
            tableRadio.addEventListener('change', ()=>{ viewMode='table'; localStorage.setItem('view-mode','table'); renderImages(); });
            document.getElementById('search-input').addEventListener('input', (e)=>{ searchQuery = e.target.value.trim(); renderImages(); });
        });

        // File handling - Full page drop zone
        const dropZone = document.getElementById('drop-zone');
        const dropOverlay = document.getElementById('drop-overlay');
        const fileInput = document.getElementById('file-input');
        let dragCounter = 0;

        // Full page drag/drop
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('visible');
            }
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('visible');
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('visible');
            if (e.dataTransfer.files.length > 0) {
                handleFiles(e.dataTransfer.files);
            }
        });

        // Small drop zone in bottom bar still works for click
        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        // Event delegation for image grid - handles all click/change events
        document.getElementById('image-grid').addEventListener('click', (e) => {
            const target = e.target;

            // Find the image container (card, list-item, or table row)
            const imageContainer = target.closest('[data-image-path]');
            if (!imageContainer) return;

            const imagePath = imageContainer.dataset.imagePath;

            // Delete button clicked
            if (target.closest('.delete-btn') || target.closest('.delete')) {
                e.preventDefault();
                imagesState = imagesState.filter(i => i.full_path !== imagePath);
                selectedPaths.delete(imagePath);
                renderImages();
                updateSelectionInfo();
                updateCostEstimate();
                scheduleStateSave();
                return;
            }

            // Regenerate button clicked
            if (target.closest('.generate-single') || target.closest('.regenerate')) {
                e.preventDefault();
                queueGeneration([imagePath]);
                return;
            }
        });

        // Separate handler for change events (checkboxes)
        document.getElementById('image-grid').addEventListener('change', (e) => {
            const target = e.target;

            // Selection checkbox changed
            if (target.classList.contains('select-checkbox') || target.classList.contains('row-select')) {
                const imageContainer = target.closest('[data-image-path]');
                if (!imageContainer) return;

                const imagePath = imageContainer.dataset.imagePath;
                if (target.checked) {
                    selectedPaths.add(imagePath);
                } else {
                    selectedPaths.delete(imagePath);
                }
                updateSelectionInfo();
                scheduleStateSave();
                return;
            }

            // Handle select-all checkbox in table view
            if (target.id === 'select-all') {
                const filtered = imagesState.filter(matchesSearch);
                filtered.forEach(img => {
                    if (target.checked) {
                        selectedPaths.add(img.full_path);
                    } else {
                        selectedPaths.delete(img.full_path);
                    }
                });
                renderImages();
                updateSelectionInfo();
                return;
            }
        });

        // Browse files button handler
        document.getElementById('browse-files').addEventListener('click', () => {
            if (isElectron) {
                // Use Electron's native file dialog (via secure preload bridge)
                window.electronAPI.showOpenDialog({
                    properties: ['openFile', 'multiSelections'],
                    filters: [
                        { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'] },
                        { name: 'All Files', extensions: ['*'] }
                    ]
                }).then(result => {
                    if (!result.canceled) {
                        // Convert file paths to File objects and handle them
                        Promise.all(result.filePaths.map(filePath => {
                            return fetch(`file://${filePath}`)
                                .then(res => res.blob())
                                .then(blob => {
                                    const filename = filePath.split(/[\\\/]/).pop();
                                    return new File([blob], filename, { type: blob.type });
                                });
                        })).then(files => {
                            handleFiles(files);
                        });
                    }
                });
            } else {
                // Fallback to regular file input for web version
                fileInput.click();
            }
        });

        // Client-side image compression to reduce upload time and server load
        async function compressImage(file, maxDimension = 1920, quality = 0.85) {
            return new Promise((resolve, reject) => {
                // Skip compression for small files or GIFs (to preserve animation)
                if (file.size < 500 * 1024 || file.type === 'image/gif') {
                    resolve(file);
                    return;
                }

                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                img.onload = () => {
                    let { width, height } = img;

                    // Only resize if larger than max dimension
                    if (width > maxDimension || height > maxDimension) {
                        const ratio = Math.min(maxDimension / width, maxDimension / height);
                        width = Math.round(width * ratio);
                        height = Math.round(height * ratio);
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob((blob) => {
                        if (blob && blob.size < file.size) {
                            // Compression helped, use compressed version
                            resolve(new File([blob], file.name, { type: 'image/jpeg' }));
                        } else {
                            // Compression didn't help, use original
                            resolve(file);
                        }
                    }, 'image/jpeg', quality);
                };

                img.onerror = () => resolve(file); // On error, use original
                img.src = URL.createObjectURL(file);
            });
        }

        async function handleFiles(files) {
            // Validate files before upload
            const validFiles = [];
            const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/webp'];
            const maxSize = 10 * 1024 * 1024; // 10MB
            const errors = [];

            Array.from(files).forEach(file => {
                if (!allowedTypes.includes(file.type)) {
                    errors.push(`${file.name}: Unsupported file type. Please use JPG, PNG, GIF, BMP, or WebP.`);
                    return;
                }
                if (file.size > maxSize) {
                    errors.push(`${file.name}: File too large. Maximum size is 10MB.`);
                    return;
                }
                if (file.size === 0) {
                    errors.push(`${file.name}: Empty file.`);
                    return;
                }
                validFiles.push(file);
            });

            if (errors.length > 0) {
                alert('Some files were rejected:\\n\\n' + errors.join('\\n'));
            }

            if (validFiles.length === 0) {
                alert('No valid files to upload.');
                return;
            }

            // Compress images before upload (shows progress for large batches)
            const compressedFiles = await Promise.all(
                validFiles.map(file => compressImage(file))
            );

            const formData = new FormData();
            compressedFiles.forEach(file => formData.append('images', file));

            try {
                const response = await fetch('/upload', {method: 'POST', body: formData});
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Upload failed');
                }

                const existingPaths = new Set(imagesState.map(i=>i.full_path));
                data.images.filter(img => !existingPaths.has(img.full_path)).forEach(img => {
                    imagesState.push({ full_path: img.full_path, file_path: img.file_path, fields: { title:'', description:'', tags:'', category: currentProfile?.categories?.[0] || '' }, status: 'ready' });
                });
                renderImages();
                updateCostEstimate();
                scheduleStateSave();
            } catch (error) {
                alert('Upload failed: ' + error.message);
            }
        }

        function createGridCard(image) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.imagePath = image.full_path;
            const checked = selectedPaths.has(image.full_path) ? 'checked' : '';
            const statusClass = image.status === 'complete' ? 'complete' :
                               image.status === 'processing' ? 'processing' :
                               image.status === 'error' ? 'error' : 'ready';
            const statusText = (image.status || 'ready').toUpperCase();

            card.innerHTML = `
                <div class="card-header">
                    <div class="card-header-left">
                        <span class="status-dot ${statusClass}"></span>
                        <span class="status-text">${statusText}</span>
                    </div>
                    <div class="card-header-right">
                        <label class="checkbox-label card-select">
                            <input type="checkbox" class="select-checkbox" ${checked}>
                            <span class="checkbox-mark"></span>
                        </label>
                        <button class="btn-icon expand-btn" title="Expand">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                        </button>
                        <button class="btn-icon delete-btn" title="Delete">
                            <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                        </button>
                    </div>
                </div>
                <div class="card-image">
                    <img src="${image.full_path}" alt="uploaded image" loading="lazy">
                </div>
                <div class="card-fields">
                    <div class="field-group">
                        <label class="field-label">TITLE</label>
                        <input type="text" class="field-input title-input" value="${image.fields.title || ''}" placeholder="Enter title...">
                    </div>
                    <div class="field-group expandable-field" style="display: none;">
                        <label class="field-label">DESCRIPTION</label>
                        <textarea class="field-input description-input" placeholder="Enter description...">${image.fields.description || ''}</textarea>
                    </div>
                    <div class="field-group">
                        <label class="field-label">TAGS</label>
                        <input type="text" class="field-input tags-input" value="${image.fields.tags || ''}" placeholder="Enter tags...">
                    </div>
                    <div class="field-group">
                        <label class="field-label">CATEGORY</label>
                        <select class="field-select category-input">
                            ${generateCategoryOptions(currentProfile.categories, image.fields.category || '')}
                        </select>
                    </div>
                </div>
                <div class="card-footer expandable-field" style="display: none;">
                    <button class="btn-secondary btn-sm regenerate">REGENERATE</button>
                </div>
            `;

            // Bind expand button
            const expandBtn = card.querySelector('.expand-btn');
            const expandableFields = card.querySelectorAll('.expandable-field');
            expandBtn.addEventListener('click', () => {
                card.classList.toggle('expanded');
                expandableFields.forEach(f => {
                    f.style.display = card.classList.contains('expanded') ? 'block' : 'none';
                });
                expandBtn.querySelector('svg').style.transform = card.classList.contains('expanded') ? 'rotate(180deg)' : '';
            });

            // Bind inputs for form field syncing
            syncInputsToState(card, image);

            // Processing/complete styles
            if (image.status === 'processing') card.classList.add('processing');
            if (image.status === 'complete') card.classList.add('complete');

            return card;
        }

        function createListItem(image) {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.dataset.imagePath = image.full_path;
            const statusClass = image.status === 'complete' ? 'complete' :
                               image.status === 'processing' ? 'processing' :
                               image.status === 'error' ? 'error' : 'ready';

            item.innerHTML = `
                <div class="list-left">
                    <label class="checkbox-label">
                        <input type="checkbox" class="select-checkbox" ${selectedPaths.has(image.full_path)?'checked':''}>
                        <span class="checkbox-mark"></span>
                    </label>
                    <div class="list-thumb">
                        <img src="${image.full_path}" alt="thumb" loading="lazy">
                    </div>
                </div>
                <div class="list-main">
                    <div class="list-file">
                        <span class="status-dot ${statusClass}"></span>
                        <span class="filename">${image.full_path.split('/').pop()}</span>
                    </div>
                    <div class="list-fields">
                        <div class="field-group">
                            <label class="field-label">TITLE</label>
                            <input type="text" class="field-input title-input" value="${image.fields.title||''}" placeholder="Enter title...">
                        </div>
                        <div class="field-group">
                            <label class="field-label">DESCRIPTION</label>
                            <textarea class="field-input description-input" placeholder="Enter description...">${image.fields.description||''}</textarea>
                        </div>
                        <div class="field-group">
                            <label class="field-label">TAGS</label>
                            <input type="text" class="field-input tags-input" value="${image.fields.tags||''}" placeholder="Enter tags...">
                        </div>
                        <div class="field-group">
                            <label class="field-label">CATEGORY</label>
                            <select class="field-select category-input">${generateCategoryOptions(currentProfile.categories, image.fields.category||'')}</select>
                        </div>
                    </div>
                </div>
                <div class="list-right">
                    <button class="btn-icon regenerate" title="Regenerate">
                        <svg viewBox="0 0 24 24" width="18" height="18"><path fill="currentColor" d="M17.65 6.35A7.95 7.95 0 0 0 12 4a8 8 0 1 0 7.75 6h-2.06A6 6 0 1 1 12 6c1.66 0 3.14.69 4.22 1.78L14 10h6V4l-2.35 2.35z"/></svg>
                    </button>
                    <button class="btn-icon delete" title="Delete">
                        <svg viewBox="0 0 24 24" width="18" height="18"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                    </button>
                </div>
            `;

            syncInputsToState(item, image);
            return item;
        }

        function queueGeneration(paths) {
            if (!checkApiKey()) return;

            // Start progress tracker for batches > 1
            if (paths.length > 1) {
                progressTracker.start(paths.length);
            }

            paths.forEach(p => {
                // Skip if cancelled
                if (progressTracker.cancelled) return;

                const img = getImageByPath(p);
                if (!img) return;
                socket.emit('generate_metadata', {
                    full_path: p,
                    profile: document.getElementById('profile-select').value,
                    settings: { apiKey: localStorage.getItem('openai-key') || '' }
                });
            });
        }

        // Socket.io handlers
        let processingCount = 0;
        
        function updateProgress() {
            const btn = document.getElementById('generate-all');
            btn.textContent = processingCount > 0 
                ? `Processing (${processingCount} remaining)` 
                : 'Generate All Metadata';
            btn.disabled = processingCount > 0;
        }

        function updateSelectionInfo() {
            document.getElementById('selection-info').textContent = `${selectedPaths.size} selected`;
            const hasSelection = selectedPaths.size > 0;
            document.getElementById('generate-selected').disabled = !hasSelection;
            document.getElementById('delete-selected').disabled = !hasSelection;
        }

        socket.on('processing_start', (data) => {
            const card = document.querySelector(`[data-image-path="${data.image}"]`);
            if (card) {
                processingCount++;
                updateProgress();
                card.classList.add('processing');
                card.classList.remove('complete');
                const badge = card.querySelector('.status-badge');
                if (badge) { badge.className = 'badge text-bg-info status-badge'; badge.textContent = 'Processing'; }
            }
            const item = getImageByPath(data.image);
            if (item) { item.status = 'processing'; if (viewMode==='table' || viewMode==='list') renderImages(); }
        });

        socket.on('metadata_update', (data) => {
            const card = document.querySelector(`[data-image-path="${data.image}"]`);
            if (card && currentProfile) {
                processingCount--;
                updateProgress();
                progressTracker.complete();
                currentProfile.required_fields.forEach(field => {
                    const input = card.querySelector(`.${field}-input`);
                    if (input) input.value = data.metadata[field] || '';
                });
                card.classList.add('complete');
                card.classList.remove('processing');
                const badge = card.querySelector('.status-badge');
                if (badge) {
                    // Show "Cached" badge if response was from cache
                    if (data.cached) {
                        badge.className = 'badge text-bg-info status-badge';
                        badge.textContent = 'Cached';
                    } else {
                        badge.className = 'badge text-bg-success status-badge';
                        badge.textContent = 'Complete';
                    }
                }

                // Show notification when all processing is done
                if (processingCount === 0 && isElectron && window.showElectronNotification) {
                    window.showElectronNotification('MetaData Refiner', 'All metadata generation completed!');
                }
            }
            // Update state
            const item = getImageByPath(data.image);
            if (item) {
                item.status = 'complete';
                item.fields = { ...item.fields, ...data.metadata };
                if (viewMode==='table' || viewMode==='list') renderImages();
                scheduleStateSave();
            }
        });

        socket.on('error', (data) => {
            processingCount--;
            updateProgress();
            progressTracker.complete(); // Count errors as completed for progress tracking
            // Show categorized error toast instead of alert
            showToast(data);
            const item = getImageByPath(data.image);
            if (item) { item.status = 'error'; if (viewMode==='table' || viewMode==='list') renderImages(); }
        });

        // Export handling
        document.getElementById('generate-all').addEventListener('click', () => {
            queueGeneration(imagesState.map(i=>i.full_path));
        });

        document.getElementById('generate-selected').addEventListener('click', () => {
            queueGeneration(Array.from(selectedPaths));
        });

        document.getElementById('delete-selected').addEventListener('click', () => {
            imagesState = imagesState.filter(i=>!selectedPaths.has(i.full_path));
            selectedPaths.clear();
            renderImages();
            updateSelectionInfo();
            updateCostEstimate();
            scheduleStateSave();
        });

        document.getElementById('cancel-batch').addEventListener('click', () => {
            progressTracker.cancel();
            // Reset any processing images back to ready state
            imagesState.forEach(img => {
                if (img.status === 'processing') {
                    img.status = 'ready';
                }
            });
            renderImages();
        });

        document.getElementById('export').addEventListener('click', async () => {
            const metadata = imagesState.map(img => {
                const obj = { full_path: img.full_path };
                currentProfile.required_fields.forEach(f=>{ obj[f] = img.fields[f] || ''; });
                return obj;
            });

            try {
                const response = await fetch('/export', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        data: metadata,
                        profile: document.getElementById('profile-select').value,
                        base_path: localStorage.getItem('base-path') || ''
                    })
                });
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'metadata.csv';
                a.click();
                a.remove();
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        });
    </script>
</body>
</html>
